%goal module_declaration;
%goal expression;
%package "snacks.lang.parser";
%class "Parser";
%import "java.io.IOException",
        "java.util.List",
        "java.util.Set",
        "snacks.lang.type.Type",
        "snacks.lang.parser.syntax.*",
        "static snacks.lang.parser.syntax.SyntaxFactory.*",
        "static java.util.Arrays.*",
        "static org.apache.commons.lang.StringUtils.join";

%terminals LPAREN, RPAREN, DQUOTE, STRING, IDENTIFIER, DOUBLE, LREGEX, RREGEX, REGEX_OPTIONS, SYMBOL, DOT, TRUE, FALSE,
    AS, BEGIN, ELSE_IF, ELSE_UNLESS, ELSE, IF, UNLESS, EMBRACE, END, ENSURE, FOR, FROM, HURL, IMPORT, RETURN, UNTIL,
    VAR, WHILE, SEMICOLON, COLON, QUOTE, TRIPLE_QUOTE, TRIPLE_DQUOTE, LSQUARE, RSQUARE, LCURLY, RCURLY, USE, CHARACTER,
    BREAK, NEWLINE, GOES_TO, APPLIES_TO, COMMA, INTEGER, ASSIGN, IN, THROWAWAY, LINTERPOLATE, DATA, RINTERPOLATE, PIPE,
    LINDEX, FWORD, DOUBLE_COLON, LFUNC, LFUNC_MULTILINE, CONTINUE, INFIX, LEFT_INFIX, RIGHT_INFIX, PREFIX, UNIT,
    QUOTED_IDENTIFIER, LPATTERN
;

%init {: report = new ParserEvents(); :};

%embed {:
    public Symbol parse(Scanner input) {
        try {
            return (Symbol) super.parse(input);
        } catch (IOException | Parser.Exception exception) {
            throw new ParseException(exception);
        }
    }

    public Symbol parse(Scanner input, short altGoal) {
        try {
            return (Symbol) super.parse(input, altGoal);
        } catch (IOException | Parser.Exception exception) {
            throw new ParseException(exception);
        }
    }
:};

%typeof IDENTIFIER = "String";
%typeof QUOTED_IDENTIFIER = "String";
%typeof FWORD = "String";
%typeof STRING = "String";
%typeof INTEGER = "Integer";
%typeof DOUBLE = "Double";
%typeof REGEX_OPTIONS = "Set<Character>";
%typeof SYMBOL = "String";
%typeof CHARACTER = "Character";

%typeof function_argument = "Argument";
%typeof import_alias = "String";
%typeof sub_import = "SubImport";
%typeof suffix_typespec = "TypeSpec";
%typeof begin_case = "Symbol[]";
%typeof qualified_identifier = "QualifiedIdentifier";
%typeof qualified_fword = "QualifiedIdentifier";
%typeof initializer_properties = "Symbol[]";
%typeof type_members = "Symbol[]";

module_declaration
    = module_expressions.e opt_terms    {: return module(e); :}
    |                                   {: return module(); :}
    ;

module_expressions
    = module_expression
    | module_expressions terms module_expression
    ;

module_expression
    = IDENTIFIER.id ASSIGN expression.e                 {: return def(id, e); :}
    | IDENTIFIER.id ASSIGN pattern.e                    {: return null; //patternCase(id, e); :}
    | IDENTIFIER.id DOUBLE_COLON type_signature.t       {: return sig(id, t); :}
    | IDENTIFIER.id INFIX INTEGER.p                     {: return op(id, p); :}
    | IDENTIFIER.id LEFT_INFIX INTEGER.p                {: return leftOp(id, p); :}
    | IDENTIFIER.id RIGHT_INFIX INTEGER.p               {: return rightOp(id, p); :}
    | IDENTIFIER.id PREFIX INTEGER.p                    {: return prefix(id, p); :}
    | IMPORT qualified_identifier.id import_alias.a     {: return importId(id, a == null ? id.getLastSegment() : a); :}
    | IMPORT qualified_identifier.id DOT THROWAWAY      {: return importWildcard(id); :}
    | FROM qualified_identifier.id IMPORT sub_imports.s {: return from(id, s); :}
    | FROM qualified_identifier.id IMPORT LPAREN sub_imports.s COMMA? RPAREN {: return from(id, s); :}
    | DATA IDENTIFIER.id IDENTIFIER.t* ASSIGN LCURLY type_properties.p COMMA? RCURLY
        {: return typeDef(id, asList(t), asList(recordDef(id, p))); :}
    | DATA IDENTIFIER.id IDENTIFIER.t* ASSIGN type_declarations.d
        {: return typeDef(id, asList(t), asList(d)); :}
    ;

type_declarations
    = type_declaration
    | type_declarations PIPE type_declaration
    ;

type_declaration
    = IDENTIFIER.id                                         {: return constDef(id); :}
    | IDENTIFIER.id LCURLY type_properties.p COMMA? RCURLY  {: return recordDef(id, p); :}
    | IDENTIFIER.id type_members.p
        {:
            List<Symbol> properties = new ArrayList<>();
            int i = 0;
            for (Symbol type : p) {
                properties.add(propDef("_" + i++, type));
            }
            return recordDef(id, properties);
        :}
    ;

type_members
    = type_signature.ts+
        {:
            List<Symbol> members = new ArrayList<>();
            for (Symbol t : ts) {
                if (t instanceof TypeReference) {
                    List<Symbol> properties = new ArrayList<>();
                    properties.add(((TypeReference) t).getType());
                    properties.addAll(((TypeReference) t).getParameters());
                    members.addAll(properties);
                } else {
                    members.add(t);
                }
            }
            return new Symbol(members.toArray(new Symbol[members.size()]));
        :}
    ;

type_properties
    = type_property
    | type_properties COMMA type_property
    ;

type_property
    = IDENTIFIER.id COLON type_signature.t nl* {: return propDef(id, t); :}
    ;

type_signature
    = primary_signature
    | primary_signature.t APPLIES_TO type_signature.f {: return fsig(t, f); :}
    ;

primary_signature
    = qualified_identifier.id+
        {:
            if (id.length == 1) {
                return ftype(id[0]);
            } else {
                List<Symbol> parameters = new ArrayList<>();
                for (int i = 1; i < id.length; i++) {
                    parameters.add(ftype(id[i]));
                }
                return typeRef(ftype(id[0]), parameters);
            }
        :}
    | UNIT                                  {: return type(qid("snacks", "lang", "Void")); :}
    | LPAREN secondary_signature.f RPAREN   {: return f; :}
    ;

secondary_signature
    = function_signature.f {: return f; :}
    | tuple_signature.t COMMA?
        {:
            List<Symbol> types = new ArrayList<>();
            for (QualifiedIdentifier id : t) {
                types.add(ftype(id));
            }
            return tsig(types);
        :}
    ;

function_signature
    = qualified_identifier.id APPLIES_TO qualified_identifier.f {: return fsig(ftype(id), ftype(f)); :}
    | qualified_identifier.id APPLIES_TO function_signature.f   {: return fsig(ftype(id), f); :}
    ;

tuple_signature
    = qualified_identifier.id
    | tuple_signature COMMA qualified_identifier.id
    ;

sub_imports
    = sub_import
    | sub_imports COMMA sub_import
    ;

sub_import
    = IDENTIFIER.id import_alias.a {: return sub(id, a == null ? id : a); :}
    ;

import_alias
    = AS IDENTIFIER.id {: return new Symbol(id); :}
    |
    ;

qualified_identifier
    = IDENTIFIER.id                                     {: return qid(id); :}
    | QUOTED_IDENTIFIER.id                              {: return qid(id); :}
    | qualified_identifier.ids DOT IDENTIFIER.id        {: return qid(ids, id); :}
    | qualified_identifier.ids DOT QUOTED_IDENTIFIER.id {: return qid(ids, id); :}
    ;

pattern
    = LPATTERN pattern_arguments COMMA? RPAREN APPLIES_TO expression
    ;

pattern_arguments
    = pattern_argument
    | pattern_arguments COMMA pattern_argument
    ;

pattern_argument
    = qualified_identifier.id
    | qualified_identifier.id pattern_parameters.p
    ;

pattern_parameters
    = IDENTIFIER
    | pattern_parameters IDENTIFIER
    ;

statement
    = primary_statement
    | WHILE expression.c COLON sequence.e term* END                 {: return loop(c, block(e)); :}
    | UNTIL expression.c COLON sequence.e term* END                 {: return loop(unary("not", c), block(e)); :}
    | FOR IDENTIFIER.v IN expression.e COLON sequence.s term* END   {: return loop(v, e, block(s)); :}
    | primary_statement.s IF expression.c                           {: return suffix(s, c); :}
    | primary_statement.s UNLESS expression.c                       {: return suffix(s, unary("not", c)); :}
    | primary_statement.s WHILE expression.c                        {: return loop(c, s); :}
    | primary_statement.s UNTIL expression.c                        {: return loop(unary("not", c), s); :}
    ;

primary_statement
    = expression
    | BREAK                                         {: return new BreakExpression(); :}
    | CONTINUE                                      {: return new ContinueExpression(); :}
    | expression.l ASSIGN primary_statement.r       {: return assign(l, r); :}
    | VAR IDENTIFIER.v                              {: return var(v); :}
    | VAR IDENTIFIER.v ASSIGN expression.e          {: return var(v, e); :}
    | VAR QUOTED_IDENTIFIER.v                       {: return var(v); :}
    | VAR QUOTED_IDENTIFIER.v ASSIGN expression.e   {: return var(v, e); :}
    | HURL string_literal.m                         {: return hurl(m); :}
    | HURL IDENTIFIER.m                             {: return hurl(id(m)); :}
    | RETURN expression.e                           {: return result(e); :}
    ;

expression
    = message.e {: return msg(e); :}
    ;

message
    = postfix_expression
    | message postfix_expression
    ;

postfix_expression
    = primary_expression
    | postfix_expression.e initializer_properties.p         {: return initializer(e, p); :}
    | postfix_expression.e DOT IDENTIFIER.id                {: return access(e, id); :}
    | postfix_expression.e LINDEX message.a COMMA? RSQUARE  {:
                                                                Symbol result = apply(id("[]"), e);
                                                                for (Symbol arg : a) {
                                                                    result = apply(result, arg);
                                                                }
                                                                return result;
                                                            :}
    ;

list
    = expression
    | list COMMA expression
    ;

primary_expression
    = IDENTIFIER.id                 {: return id(id); :}
    | QUOTED_IDENTIFIER.id          {: return quoted(id); :}
    | INTEGER.val                   {: return literal(val); :}
    | DOUBLE.val                    {: return literal(val); :}
    | TRUE                          {: return literal(true); :}
    | FALSE                         {: return literal(false); :}
    | CHARACTER.c                   {: return literal(c); :}
    | SYMBOL.s                      {: return symbol(s); :}
    | LPAREN expression.e RPAREN    {: return e; :}
    | UNIT                          {: return unit(); :}
    | string_literal
    | function_literal
    | map_literal
    | list_literal
    | tuple_literal
    | set_literal
    | block
    | conditional
    | exceptional
    | LREGEX interpolation_list.e RREGEX REGEX_OPTIONS.o    {: return regex(asList(e), o); :}
    ;

string_literal
    = QUOTE STRING.val QUOTE                            {: return literal(val); :}
    | QUOTE QUOTE                                       {: return literal(""); :}
    | DQUOTE interpolation_list.e DQUOTE                {: return e; :}
    | TRIPLE_QUOTE STRING.val TRIPLE_QUOTE              {: return literal(val); :}
    | TRIPLE_DQUOTE interpolation_list.e TRIPLE_DQUOTE  {: return e; :}
    ;

initializer_properties
    = LCURLY properties.p COMMA? RCURLY {: return new Symbol(p); :}
    | LCURLY COMMA? RCURLY              {: return new Symbol(new Symbol[0]); :}
    ;

properties
    = property
    | properties COMMA property
    ;

property
    = IDENTIFIER.id ASSIGN expression.e nl* {: return property(id, e); :}
    ;

list_literal
    = LSQUARE list.e COMMA? RSQUARE {: return list(e); :}
    | LSQUARE RSQUARE               {: return list(); :}
    ;

tuple_literal
    = LPAREN COMMA? RPAREN                              {: return tuple(); :}
    | LPAREN expression.e COMMA RPAREN                  {: return tuple(e); :}
    | LPAREN expression.e COMMA list.es COMMA? RPAREN   {: return tuple(e, es); :}
    ;

set_literal
    = LCURLY COMMA RCURLY                               {: return set(); :}
    | LCURLY expression.e COMMA RCURLY                  {: return set(e); :}
    | LCURLY expression.e COMMA list.es COMMA? RCURLY   {: return set(e, es); :}
    ;

map_literal
    = LCURLY COLON RCURLY                   {: return map(); :}
    | LCURLY keyed_list.e COMMA? nl* RCURLY {: return map(e); :}
    | LCURLY map_list.e COMMA? nl* RCURLY   {: return map(e); :}
    ;

block
    = LCURLY term* RCURLY               {: return invokable(block()); :}
    | LCURLY sequence.e term* RCURLY    {: return invokable(block(e)); :}
    ;

sequence
    = statement
    | sequence term+ statement
    ;

function_literal
    = UNIT APPLIES_TO LCURLY sequence.e term* RCURLY @ PRECSYM  {: return invokable(block(e)); :}
    | UNIT APPLIES_TO expression.e                              {: return invokable(e); :}
    | LFUNC APPLIES_TO expression.e RPAREN                      {: return invokable(e); :}
    | LFUNC function_arguments.a APPLIES_TO expression.e RPAREN
        {:
            Symbol expression = e;
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            expression = func(a[0], expression);
            return expression;
        :}
    | LFUNC_MULTILINE function_arguments.a APPLIES_TO sequence.e term* RCURLY
        {:
            Symbol expression = block(e);
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            return func(a[0], expression);
        :}
    | LFUNC function_arguments.a RPAREN suffix_typespec.t APPLIES_TO LCURLY sequence.e term* RCURLY @ PRECSYM
        {:
            Symbol expression = block(e);
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            return func(a[0], expression, t);
        :}
    | LFUNC function_arguments.a RPAREN suffix_typespec.t APPLIES_TO expression.e
        {:
            Symbol expression = e;
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            return func(a[0], expression, t);
        :}
    ;

conditional
    = conditional_case.h default_case.e END                     {: return conditional(h, null, e); :}
    | conditional_case.h alternative_cases.t default_case.e END {: return conditional(h, t, e); :}
    ;

conditional_case
    = IF expression.c COLON sequence.e term*        {: return condition(c, block(e)); :}
    | UNLESS expression.c COLON sequence.e term*    {: return condition(unary("not", c), block(e)); :}
    ;

alternative_cases
    = alternative_case
    | alternative_cases alternative_case
    ;

alternative_case
    = ELSE_IF expression.c COLON sequence.e term*       {: return condition(c, block(e)); :}
    | ELSE_UNLESS expression.c COLON sequence.e term*   {: return condition(unary("not", c), block(e)); :}
    ;

default_case
    = ELSE sequence.e term* {: return block(e); :}
    |                       {: return nop(); :}
    ;

exceptional
    = begin_case.u sequence.s term* embrace_cases.e ensure_case.f END   {: return begin(u, block(s), e, f); :}
    | begin_case.u sequence.s term* embrace_cases.e END                 {: return begin(u, block(s), e, null); :}
    | begin_case.u sequence.s term* ensure_case.f END                   {: return begin(u, block(s), null, f); :}
    | begin_case.u sequence.s term* END                                 {: return begin(u, block(s), null, null); :}
    ;

begin_case
    = BEGIN             {: return new Symbol(null); :}
    | use_cases.u term+ {: return new Symbol(u); :}
    ;

use_cases
    = use_case
    | use_cases term+ use_case
    ;

use_case
    = USE expression.e                      {: return use(null, e); :}
    | USE IDENTIFIER.id ASSIGN expression.e {: return use(id, e); :}
    ;

embrace_cases
    = embrace_case
    | embrace_cases embrace_case
    ;

embrace_case
    = EMBRACE IDENTIFIER.a embrace_typespec.t APPLIES_TO sequence.e term*   {: return embrace(a, t, block(e)); :}
    ;

embrace_typespec
    = COLON qualified_identifier.id {: return type(id); :}
    |                               {: return type(qid("snacks", "lang", "SnacksException")); :}
    ;

ensure_case
    = ENSURE sequence.e term* {: return block(e); :}
    ;

keyed_list
    = keyed_entry
    | keyed_list COMMA keyed_entry
    ;

keyed_entry
    = IDENTIFIER.k COLON expression.v {: return entry(symbol(k), v); :}
    ;

map_list
    = map_entry
    | map_list COMMA map_entry
    ;

map_entry
    = expression.k GOES_TO expression.v {: return entry(k, v); :}
    ;

function_arguments
    = function_argument
    | function_arguments function_argument
    ;

function_argument
    = FWORD.a suffix_typespec.t {: return arg(a, t); :}
    | THROWAWAY                 {: return arg("_", null); :}
    ;

suffix_typespec
    = COLON qualified_fword.t {: return type(t); :}
    |
    ;

qualified_fword
    = FWORD.id                          {: return qid(id); :}
    | qualified_fword.ids DOT FWORD.id  {: return qid(ids, id); :}
    ;

interpolation_list
    = interpolation.e                       {: return apply(id("stringy"), e); :}
    | interpolation_list.es interpolation.e {: return apply(apply(id("concat"), es), apply(id("stringy"), e)); :}
    ;

interpolation
    = STRING.val                                {: return literal(val); :}
    | LINTERPOLATE expression.e RINTERPOLATE    {: return e; :}
    ;

opt_terms
    = terms
    |
    ;

terms
    = term
    | terms term
    ;

term
    = nl
    | SEMICOLON
    ;

nl
    = NEWLINE
    ;
