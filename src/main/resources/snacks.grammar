%goal module_declaration;
%goal expression;
%package "iddic.lang.compiler";
%class "Parser";
%import "static java.util.Collections.emptyList",
        "static iddic.lang.compiler.ParserUtils.*",
        "static iddic.lang.compiler.Scanner.*",
        "static iddic.lang.compiler.SyntaxFactory.*",
        "static iddic.lang.compiler.Terminals.*",
        "java.io.IOException",
        "java.util.List",
        "java.util.Set",
        "iddic.lang.IddicException",
        "iddic.lang.compiler.SyntaxException",
        "iddic.lang.compiler.syntax.*";

%terminals IDENTIFIER, STRING, INTEGER, DOUBLE, BOOLEAN, CHARACTER, REGEX_OPTIONS, NOTHING,
           SEMICOLON, NEWLINE, ACCESSOR, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, CURLY_BRACE_OPEN, CURLY_BRACE_CLOSE,
           SQUARE_BRACE_OPEN, SQUARE_BRACE_CLOSE, SINGLE_QUOTE_OPEN, SINGLE_QUOTE_CLOSE, DOUBLE_QUOTE_OPEN,
           DOUBLE_QUOTE_CLOSE, AT, COMMA, APPLIES_TO, GOES_TO, ASSIGN, EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN,
           GREATER_THAN_EQUALS, LESS_THAN_EQUALS, IS, IS_NOT, IN, NOT_IN, APPLY, LOGICAL_AND, LOGICAL_OR, LOGICAL_NOT,
           BITWISE_XOR, BITWISE_OR, BITWISE_AND, BITWISE_NOT, PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EXPONENT,
           SHIFT_LEFT, SIGNED_SHIFT_RIGHT, SHIFT_RIGHT, COALESCE, COLON, IMPORT, AS, FROM, IF, THEN, ELSE, UNLESS, END,
           ELSE_IF, ELSE_UNLESS, VAR, HEREDOC_OPEN, HEREDOC_CLOSE, NOWDOC_OPEN, NOWDOC_CLOSE, ROOT, BEGIN, EMBRACE,
           ENSURE, REGEX_OPEN, REGEX_CLOSE, INDEXER_OPEN, RANGE, XRANGE, RETURN, COLON, SYMBOL_SIGIL, SYMBOL;

%init {: report = new ParserEvents(); :};

%embed {:

    @Override
    public SyntaxNode parse(beaver.Scanner source) throws java.io.IOException, beaver.Parser.Exception {
        return (SyntaxNode) super.parse(source);
    }

    @Override
    public SyntaxNode parse(beaver.Scanner source, short alt_goal_marker_id) throws java.io.IOException, beaver.Parser.Exception {
        return (SyntaxNode) super.parse(source, alt_goal_marker_id);
    }
:};

%left PARENTHESIS_OPEN, CURLY_BRACE_OPEN, SQUARE_BRACE_OPEN;
%right EXPONENT;
%right PLUS, MINUS, BITWISE_NOT;
%left MULTIPLY, DIVIDE, MODULO;
%left PLUS, MINUS;
%left BITWISE_AND;
%left BITWISE_OR;
%left BITWISE_XOR;
%left COALESCE;
%left SHIFT_LEFT, SIGNED_SHIFT_RIGHT, SHIFT_RIGHT;
%left IS, IS_NOT, EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_THAN_EQUALS, LESS_THAN_EQUALS, IN, NOT_IN;
%right LOGICAL_NOT;
%left LOGICAL_AND;
%left LOGICAL_OR;
%right APPLY;
%left RANGE, XRANGE;
%right ASSIGN;
%left COMMA;
%right APPLIES_TO;

%typeof IDENTIFIER = "String";
%typeof STRING = "String";
%typeof INTEGER = "Integer";
%typeof BOOLEAN = "Boolean";
%typeof SYMBOL = "String";
%typeof DOUBLE = "Double";
%typeof CHARACTER = "Character";
%typeof REGEX_OPTIONS = "Set";
%typeof import_identifier_alias = "IdentifierAlias";
%typeof meta_annotation = "MetaAnnotation";
%typeof declaration = "Declaration";
%typeof from_sub_identifier = "SubImport";
%typeof map_element = "MapElement";

module_declaration
    = module_expressions.e opt_terms
        {: return module(e); :}
    | opt_terms
        {: return module(); :}
    ;

module_expressions
    = module_expression
    | module_expressions terms module_expression
    ;

module_expression
    = import_expression
    | from_expression
    | annotated_declaration
    ;

import_expression
    = IMPORT qualified_identifier.id import_identifier_alias.a?
        {: return imports(qualifiedId(id), a == null ? alias(id[id.length - 1]) : a); :}
    ;

qualified_identifier
    = IDENTIFIER
    | qualified_identifier ACCESSOR IDENTIFIER
    ;

import_identifier_alias
    = AS opt_nls IDENTIFIER.id
        {: return alias(id); :}
    ;

from_expression
    = FROM opt_nls qualified_identifier.id IMPORT from_identifier_list.ids
        {: return from(qualifiedId(id), ids); :}
    | FROM opt_nls qualified_identifier.id IMPORT lparen from_identifier_list.ids comma? rparen
        {: return from(qualifiedId(id), ids); :}
    ;

from_identifier_list
    = from_sub_identifier
    | from_identifier_list comma from_sub_identifier
    ;

from_sub_identifier
    = IDENTIFIER.id
        {: return sub(id, alias(id)); :}
    | IDENTIFIER.id import_identifier_alias.a
        {: return sub(id, a); :}
    ;

annotated_declaration
    = declaration
    | meta_annotations.m opt_nls declaration.d
        {: return declaration(d, m); :}
    ;

meta_annotations
    = meta_annotation
    | meta_annotations opt_nls meta_annotation
    ;

meta_annotation
    = AT IDENTIFIER.id
        {: return meta(id, nothing()); :}
    | AT IDENTIFIER.id meta_value.v
        {: return meta(id, v); :}
    ;

meta_value
    = meta_default_value
    | map_literal
    ;

meta_default_value
    = literal_expression
    | block_expression
    | list_literal
    | tuple_literal
    | symbol_literal
    | parenthetical_expression
    | function_literal
    ;

declaration
    = IDENTIFIER.id ASSIGN expression.e
        {: return declaration(id, e); :}
    | IDENTIFIER.id type_spec ASSIGN expression.e
        {: return declaration(id, e); :}
    ;

type_spec
    = COLON qualified_identifier.id {: return qualifiedId(id); :}
    ;

function_literal
    = lparen identifiers.as applies_to expression.e rparen
        {: return func(funcArgs(as), e); :}
    | lcurly identifiers.as applies_to expression.e rcurly
        {: return func(funcArgs(as), e); :}
    | lcurly identifiers.as applies_to sequence_expressions.e rcurly
        {: return func(funcArgs(as), block(e)); :}
    | lparen identifiers.as rparen applies_to expression.e
        {: return func(funcArgs(as), e); :}
    ;

function_args
    = function_arg
    | function_args function_arg
    ;

function_arg
    = IDENTIFIER.id type_spec {: return id; :}
    ;

identifiers
    = IDENTIFIER @ PRECSYM
    | identifiers IDENTIFIER
    ;

block_expression
    = lcurly RETURN expression.e rcurly
        {: return block(result(e)); :}
    | lcurly RETURN rcurly
        {: return block(result(nothing())); :}
    | lcurly variable_declaration.v rcurly
        {: return block(v); :}
    | lcurly identifiers.e rcurly
        {: return block(transformSelect(e)); :}
    | lcurly expression.e rcurly
        {: return block(e); :}
    | lcurly sequence_expressions.e rcurly
        {: return block(e); :}
    | lcurly rcurly
        {: return block(); :}
    ;

sequence_expressions
    = sequence_expression
    | sequence_expressions sequence_expression
    ;

sequence_expression
    = variable_declaration.e terms
        {: return e; :}
    | expression.e terms
        {: return e; :}
    | IDENTIFIER.id terms
        {: return id(id); :}
    | RETURN expression.e terms
        {: return result(e); :}
    | RETURN terms
        {: return result(nothing()); :}
    | terms
        {: return VoidExpression.INSTANCE; :}
    ;

variable_declaration
    = VAR IDENTIFIER.id ASSIGN expression.e
        {: return var(id, e); :}
    ;

expression
    = arguments_expression
    | expression.l EXPONENT opt_nls expression.r            {: return binary("**", l, r); :}
    | LOGICAL_NOT expression.e                              {: return unary("not", e); :}
    | PLUS expression.e                                     {: return unary("positive", e); :}
    | MINUS expression.e                                    {: return unary("negative", e); :}
    | BITWISE_NOT expression.e                              {: return unary("~", e); :}
    | expression.l APPLY opt_nls expression.r               {: return binary("$", l, r); :}
    | expression.l LOGICAL_OR opt_nls expression.r          {: return binary("or", l, r); :}
    | expression.l LOGICAL_AND opt_nls expression.r         {: return binary("and", l, r); :}
    | expression.l IS opt_nls expression.r                  {: return binary("is", l, r); :}
    | expression.l IS_NOT opt_nls expression.r              {: return binary("is not", l, r); :}
    | expression.l EQUALS opt_nls expression.r              {: return binary("==", l, r); :}
    | expression.l NOT_EQUALS opt_nls expression.r          {: return binary("<>", l, r); :}
    | expression.l LESS_THAN opt_nls expression.r           {: return binary("<", l, r); :}
    | expression.l GREATER_THAN opt_nls expression.r        {: return binary(">", l, r); :}
    | expression.l LESS_THAN_EQUALS opt_nls expression.r    {: return binary("<=", l, r); :}
    | expression.l GREATER_THAN_EQUALS opt_nls expression.r {: return binary(">=", l, r); :}
    | expression.l IN opt_nls expression.r                  {: return binary("in", l, r); :}
    | expression.l NOT_IN opt_nls expression.r              {: return binary("not in", l, r); :}
    | expression.l SHIFT_LEFT opt_nls expression.r          {: return binary("<<", l, r); :}
    | expression.l SIGNED_SHIFT_RIGHT opt_nls expression.r  {: return binary(">>", l, r); :}
    | expression.l SHIFT_RIGHT opt_nls expression.r         {: return binary(">>>", l, r); :}
    | expression.l COALESCE opt_nls expression.r            {: return binary("?", l, r); :}
    | expression.l BITWISE_XOR opt_nls expression.r         {: return binary("^", l, r); :}
    | expression.l BITWISE_OR opt_nls expression.r          {: return binary("|", l, r); :}
    | expression.l BITWISE_AND opt_nls expression.r         {: return binary("&", l, r); :}
    | expression.l PLUS opt_nls expression.r                {: return binary("+", l, r); :}
    | expression.l MINUS opt_nls expression.r               {: return binary("-", l, r); :}
    | expression.l MULTIPLY opt_nls expression.r            {: return binary("*", l, r); :}
    | expression.l DIVIDE opt_nls expression.r              {: return binary("/", l, r); :}
    | expression.l MODULO opt_nls expression.r              {: return binary("%", l, r); :}
    | expression.l RANGE opt_nls expression.r               {: return range(l, r); :}
    | expression.l XRANGE opt_nls expression.r              {: return xrange(l, r); :}
    ;

arguments_expression
    = selector_expression
    | selector_expression.e arguments_list.a
        {: return select(e, args(a)); :}
    ;

arguments_list
    = selector_expression
    | arguments_list selector_expression
    ;

selector_expression
    = primary_expression.e
        {: return e; :}
    | selector_expression.e selector.s
        {: return select(e, s); :}
    ;

selector
    = accessor_expression
    | indexer_expression
    ;

accessor_expression
    = ACCESSOR IDENTIFIER.id
        {: return access(id); :}
    | ACCESSOR IDENTIFIER.id ASSIGN expression.e
        {: return access(id, e); :}
    ;

indexer_expression
    = indexer expression_list.a rsquare
        {: return index(a); :}
    | indexer expression_list.a rsquare ASSIGN expression.e
        {: return index(args(a), e); :}
    ;

indexer
    = INDEXER_OPEN opt_nls
    ;

primary_expression
    = IDENTIFIER.value
        {: return id(value); :}
    | ROOT qualified_identifier.id
        {: return root(id); :}
    | function_literal
    | tuple_literal
    | list_literal
    | parenthetical_expression
    | block_expression
    | set_literal
    | map_literal
    | literal_expression
    | symbol_literal
    | conditional_expression
    | embrace_expression
    ;

parenthetical_expression
    = lparen expression.e rparen
        {: return e; :}
    | lparen expression.e nls rparen
        {: return e; :}
    | lparen identifiers.a rparen
        {: return transformSelect(a); :}
    | lparen identifiers.a nls rparen
        {: return transformSelect(a); :}
    | lparen identifiers.a parenthetical_expression.e rparen
        {: return transformSelect(a, e); :}
    | lparen identifiers.a parenthetical_expression.e nls rparen
        {: return transformSelect(a, e); :}
    ;

list_literal
    = lsquare expression_list.e comma? rsquare
        {: return list(e); :}
    | lsquare rsquare
        {: return list(); :}
    ;

tuple_literal
    = lparen expression_list.e comma? rparen
        {: return tuple(e); :}
    | lparen identifiers.a comma rparen
        {: return tuple(transformSelect(a)); :}
    | lparen rparen
        {: return tuple(); :}
    ;

set_literal
    = lcurly expression_list.e comma? rcurly
        {: return set(e); :}
    | lcurly comma rcurly
        {: return set(); :}
    ;

expression_list
    = expression
    | expression_list comma expression
    ;

map_literal
    = lcurly map_elements.d comma? rcurly
        {: return map(d); :}
    | lcurly COLON opt_nls rcurly
        {: return map(); :}
    ;

map_elements
    = map_element
    | map_elements comma map_element
    ;

map_element
    = map_key.k opt_nls expression.v opt_nls
        {: return entry(k, v); :}
    ;

map_key
    = key_symbol.s
        {: return s; :}
    | expression.e GOES_TO
        {: return e; :}
    ;

literal_expression
    = string_literal
    | regex_literal
    | INTEGER.value
        {: return literal(value); :}
    | DOUBLE.value
        {: return literal(value); :}
    | BOOLEAN.value
        {: return literal(value); :}
    | CHARACTER.value
        {: return literal(value); :}
    | NOTHING
        {: return nothing(); :}
    ;

key_symbol
    = IDENTIFIER.s COLON        {: return symbol(s); :}
    | SYMBOL.s COLON            {: return symbol(s); :}
    | EXPONENT COLON            {: return symbol("**"); :}
    | PLUS COLON                {: return symbol("+"); :}
    | MINUS COLON               {: return symbol("-"); :}
    | BITWISE_NOT COLON         {: return symbol("~"); :}
    | EQUALS COLON              {: return symbol("=="); :}
    | LESS_THAN COLON           {: return symbol("<"); :}
    | GREATER_THAN COLON        {: return symbol(">"); :}
    | LESS_THAN_EQUALS COLON    {: return symbol("<="); :}
    | GREATER_THAN_EQUALS COLON {: return symbol(">="); :}
    | IN COLON                  {: return symbol("in"); :}
    | SHIFT_LEFT COLON          {: return symbol("<<"); :}
    | SIGNED_SHIFT_RIGHT COLON  {: return symbol(">>"); :}
    | SHIFT_RIGHT COLON         {: return symbol(">>>"); :}
    | COALESCE COLON            {: return symbol("?:"); :}
    | BITWISE_XOR COLON         {: return symbol("^"); :}
    | BITWISE_OR COLON          {: return symbol("|"); :}
    | BITWISE_AND COLON         {: return symbol("&"); :}
    | MULTIPLY COLON            {: return symbol("*"); :}
    | DIVIDE COLON              {: return symbol("/"); :}
    | MODULO COLON              {: return symbol("%"); :}
    | RANGE COLON               {: return symbol(".."); :}
    | XRANGE COLON              {: return symbol("..."); :}
    ;

symbol_literal
    = SYMBOL_SIGIL IDENTIFIER.s        {: return symbol(s); :}
    | SYMBOL_SIGIL SYMBOL.s            {: return symbol(s); :}
    | SYMBOL_SIGIL EXPONENT            {: return symbol("**"); :}
    | SYMBOL_SIGIL PLUS                {: return symbol("+"); :}
    | SYMBOL_SIGIL MINUS               {: return symbol("-"); :}
    | SYMBOL_SIGIL BITWISE_NOT         {: return symbol("~"); :}
    | SYMBOL_SIGIL EQUALS              {: return symbol("=="); :}
    | SYMBOL_SIGIL LESS_THAN           {: return symbol("<"); :}
    | SYMBOL_SIGIL GREATER_THAN        {: return symbol(">"); :}
    | SYMBOL_SIGIL LESS_THAN_EQUALS    {: return symbol("<="); :}
    | SYMBOL_SIGIL GREATER_THAN_EQUALS {: return symbol(">="); :}
    | SYMBOL_SIGIL IN                  {: return symbol("in"); :}
    | SYMBOL_SIGIL SHIFT_LEFT          {: return symbol("<<"); :}
    | SYMBOL_SIGIL SIGNED_SHIFT_RIGHT  {: return symbol(">>"); :}
    | SYMBOL_SIGIL SHIFT_RIGHT         {: return symbol(">>>"); :}
    | SYMBOL_SIGIL COALESCE            {: return symbol("?:"); :}
    | SYMBOL_SIGIL BITWISE_XOR         {: return symbol("^"); :}
    | SYMBOL_SIGIL BITWISE_OR          {: return symbol("|"); :}
    | SYMBOL_SIGIL BITWISE_AND         {: return symbol("&"); :}
    | SYMBOL_SIGIL MULTIPLY            {: return symbol("*"); :}
    | SYMBOL_SIGIL DIVIDE              {: return symbol("/"); :}
    | SYMBOL_SIGIL MODULO              {: return symbol("%"); :}
    | SYMBOL_SIGIL RANGE               {: return symbol(".."); :}
    | SYMBOL_SIGIL XRANGE              {: return symbol("..."); :}
    ;

conditional_expression
    = conditional_head.h opt_nls END
        {: return conditional(h); :}
    | conditional_head.h opt_nls conditional_tail.t opt_nls END
        {: return conditional(h, t); :}
    ;

conditional_head
    = IF expression.c opt_nls THEN opt_nls expression.e
        {: return truthy(c, e); :}
    | IF expression.c opt_nls THEN opt_nls sequence_expressions.e
        {: return truthy(c, e.length == 1 ? e[0] : block(e)); :}
    | UNLESS expression.c opt_nls THEN opt_nls expression.e
        {: return falsy(c, e); :}
    | UNLESS expression.c opt_nls THEN opt_nls sequence_expressions.e
        {: return falsy(c, e.length == 1 ? e[0] : block(e)); :}
    ;

conditional_tail
    = conditional_alternative
    | conditional_tail opt_nls conditional_alternative
    ;

conditional_alternative
    = ELSE_IF expression.c opt_nls THEN opt_nls expression.e
        {: return truthy(c, e); :}
    | ELSE_IF expression.c opt_nls THEN opt_nls sequence_expressions.e
        {: return truthy(c, e.length == 1 ? e[0] : block(e)); :}
    | ELSE_UNLESS expression.c opt_nls THEN opt_nls expression.e
        {: return falsy(c, e); :}
    | ELSE_UNLESS expression.c opt_nls THEN opt_nls sequence_expressions.e
        {: return falsy(c, e.length == 1 ? e[0] : block(e)); :}
    | ELSE opt_nls expression.e
        {: return e; :}
    | ELSE opt_nls sequence_expressions.e
        {: return e.length == 1 ? e[0] : block(e); :}
    ;

embrace_expression
    = begin_clause.b ensure_clause.e END
        {: return embrace(b, VoidExpression.INSTANCE, e); :}
    | begin_clause.b embrace_clause.r END
        {: return embrace(b, r, VoidExpression.INSTANCE); :}
    | begin_clause.b embrace_clause.r ensure_clause.e END
        {: return embrace(b, r, e); :}
    ;

begin_clause
    = BEGIN opt_nls expression.e opt_nls
        {: return e; :}
    | BEGIN opt_nls sequence_expressions.e opt_nls
        {: return e.length == 1 ? e[0] : block(e); :}
    ;

embrace_clause
    = EMBRACE opt_nls expression.e opt_nls
        {: return e; :}
    | EMBRACE opt_nls IDENTIFIER.id applies_to expression.e opt_nls
        {: return func(funcArgs(id), e); :}
    | EMBRACE opt_nls IDENTIFIER.id applies_to sequence_expressions.e opt_nls
        {: return func(funcArgs(id), e.length == 1 ? e[0] : block(e)); :}
    ;

ensure_clause
    = ENSURE opt_nls expression.e opt_nls
        {: return e; :}
    | ENSURE opt_nls sequence_expressions.e opt_nls
        {: return e.length == 1 ? e[0] : block(e); :}
    ;

string_literal
    = HEREDOC_OPEN HEREDOC_CLOSE
        {: return literal(""); :}
    | NOWDOC_OPEN NOWDOC_CLOSE
        {: return literal(""); :}
    | DOUBLE_QUOTE_OPEN DOUBLE_QUOTE_CLOSE
        {: return literal(""); :}
    | SINGLE_QUOTE_OPEN SINGLE_QUOTE_CLOSE
        {: return literal(""); :}
    | HEREDOC_OPEN interpolated_elements.e HEREDOC_CLOSE
        {: return interpolate(e); :}
    | NOWDOC_OPEN STRING.value NOWDOC_CLOSE
        {: return literal(value); :}
    | DOUBLE_QUOTE_OPEN interpolated_elements.e DOUBLE_QUOTE_CLOSE
        {: return interpolate(e); :}
    | SINGLE_QUOTE_OPEN STRING.value SINGLE_QUOTE_CLOSE
        {: return literal(value); :}
    ;

regex_literal
    = REGEX_OPEN interpolated_elements.e REGEX_CLOSE REGEX_OPTIONS.op
        {: return regex(interpolate(e), op); :}
    ;

interpolated_elements
    = interpolated_element
    | interpolated_elements interpolated_element
    ;

interpolated_element
    = expression
    | STRING.value
        {: return literal(value); :}
    ;

opt_terms
    = terms
    |
    ;

terms
    = term
    | terms term
    ;

term
    = NEWLINE
    | SEMICOLON
    ;

opt_nls
    = nls
    |
    ;

nls
    = NEWLINE @ PRECSYM
    | nls NEWLINE
    ;

lparen
    = PARENTHESIS_OPEN opt_nls
    ;

rparen
    = PARENTHESIS_CLOSE
    ;

lcurly
    = CURLY_BRACE_OPEN opt_nls
    ;

rcurly
    = CURLY_BRACE_CLOSE
    ;

lsquare
    = SQUARE_BRACE_OPEN opt_nls
    ;

rsquare
    = SQUARE_BRACE_CLOSE
    ;

comma
    = COMMA opt_nls
    ;

applies_to
    = APPLIES_TO opt_nls
    ;
