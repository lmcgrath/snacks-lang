%goal module_declaration;
%goal expression;
%package "snacks.lang.parser";
%class "Parser";
%import "java.io.IOException",
        "java.util.List",
        "java.util.Set",
        "snacks.lang.Type",
        "snacks.lang.parser.syntax.*",
        "static snacks.lang.parser.syntax.SyntaxFactory.*",
        "static java.util.Arrays.*",
        "static org.apache.commons.lang.StringUtils.join";

%terminals LPAREN, RPAREN, DQUOTE, STRING, IDENTIFIER, DOUBLE, NOTHING, LREGEX, RREGEX, REGEX_OPTIONS, SYMBOL, DOT,
    KEY_SYMBOL, TRUE, FALSE, AS, BEGIN, ELSE_IF, ELSE_UNLESS, ELSE, IF, UNLESS, EMBRACE, END, ENSURE, FOR, FROM, HURL,
    IMPORT, RETURN, THEN, UNTIL, VAR, WHILE, SEMICOLON, COLON, QUOTE, TRIPLE_QUOTE, TRIPLE_DQUOTE, LSQUARE, RSQUARE,
    LCURLY, RCURLY, USE, CHARACTER, DO, BREAK, NEWLINE, GOES_TO, APPLIES_TO, COMMA, INTEGER, ASSIGN, IN, THROWAWAY,
    LINTERPOLATE, RINTERPOLATE, LINDEX, LARG, FWORD, DOUBLE_COLON, LFUNC, LFUNC_MULTILINE, CONTINUE, OPERATOR, LEFT_OPERATOR,
    RIGHT_OPERATOR, QUOTED_IDENTIFIER
;

%init {: report = new ParserEvents(); :};

%embed {:
    public Symbol parse(Scanner input) {
        try {
            return (Symbol) super.parse(input);
        } catch (IOException | Parser.Exception exception) {
            throw new ParseException(exception);
        }
    }

    public Symbol parse(Scanner input, short altGoal) {
        try {
            return (Symbol) super.parse(input, altGoal);
        } catch (IOException | Parser.Exception exception) {
            throw new ParseException(exception);
        }
    }
:};

%typeof IDENTIFIER = "String";
%typeof QUOTED_IDENTIFIER = "String";
%typeof FWORD = "String";
%typeof STRING = "String";
%typeof INTEGER = "Integer";
%typeof DOUBLE = "Double";
%typeof REGEX_OPTIONS = "Set<Character>";
%typeof SYMBOL = "String";
%typeof KEY_SYMBOL = "String";
%typeof CHARACTER = "Character";

%typeof function_argument = "Argument";
%typeof import_alias = "String";
%typeof sub_import = "SubImport";
%typeof suffix_typespec = "TypeSpec";
%typeof function_typespec = "TypeSpec";
%typeof opt_function_arguments = "Symbol[]";
%typeof begin_case = "Symbol[]";
%typeof qualified_identifier = "QualifiedIdentifier";
%typeof qualified_fword = "QualifiedIdentifier";

module_declaration
    = module_expressions.e opt_terms    {: return module(e); :}
    |                                   {: return module(); :}
    ;

module_expressions
    = module_expression
    | module_expressions terms module_expression
    ;

module_expression
    = IDENTIFIER.id ASSIGN expression.e                 {: return def(id, e); :}
    | IDENTIFIER.id DOUBLE_COLON type_signature.t       {: return sig(id, t); :}
    | OPERATOR INTEGER.p IDENTIFIER.id                  {: return op(id, p); :}
    | LEFT_OPERATOR INTEGER.p IDENTIFIER.id             {: return leftOp(id, p); :}
    | RIGHT_OPERATOR INTEGER.p IDENTIFIER.id            {: return rightOp(id, p); :}
    | IMPORT qualified_identifier.id import_alias.a     {: return importId(id, a == null ? id.getLastSegment() : a); :}
    | IMPORT qualified_identifier.id DOT THROWAWAY      {: return importWildcard(id); :}
    | FROM qualified_identifier.id IMPORT sub_imports.s {: return from(id, s); :}
    | FROM qualified_identifier.id IMPORT LPAREN sub_imports.s COMMA? RPAREN {: return from(id, s); :}
    ;

type_signature
    = primary_signature
    | primary_signature.t APPLIES_TO type_signature.f {: return fsig(t, f); :}
    ;

primary_signature
    = qualified_identifier.id           {: return type(id); :}
    | LFUNC COMMA? RPAREN               {: return type(qid("snacks", "lang", "Void")); :}
    | LFUNC function_signature.f RPAREN {: return f; :}
    | LPAREN tuple_signature.t COMMA? RPAREN
        {:
            List<Symbol> types = new ArrayList<>();
            for (QualifiedIdentifier id : t) {
                types.add(type(id));
            }
            return tsig(types);
        :}
    ;

function_signature
    = qualified_identifier.id                                 {: return type(id); :}
    | qualified_fword.id                                      {: return type(id); :}
    | qualified_identifier.id APPLIES_TO function_signature.f {: return fsig(type(id), f); :}
    | qualified_fword.id APPLIES_TO function_signature.f      {: return fsig(type(id), f); :}
    ;

tuple_signature
    = qualified_identifier.id
    | tuple_signature COMMA qualified_identifier.id
    ;

sub_imports
    = sub_import
    | sub_imports COMMA sub_import
    ;

sub_import
    = IDENTIFIER.id import_alias.a {: return sub(id, a == null ? id : a); :}
    ;

import_alias
    = AS IDENTIFIER.id {: return new Symbol(id); :}
    |
    ;

qualified_identifier
    = IDENTIFIER.id                                     {: return qid(id); :}
    | QUOTED_IDENTIFIER.id                              {: return qid(id); :}
    | qualified_identifier.ids DOT IDENTIFIER.id        {: return qid(ids, id); :}
    | qualified_identifier.ids DOT QUOTED_IDENTIFIER.id {: return qid(ids, id); :}
    ;

statement
    = expression
    | BREAK                                                             {: return new BreakExpression(); :}
    | CONTINUE                                                          {: return new ContinueExpression(); :}
    | VAR IDENTIFIER.v                                                  {: return var(v); :}
    | VAR IDENTIFIER.v ASSIGN expression.e                              {: return var(v, e); :}
    | VAR QUOTED_IDENTIFIER.v                                           {: return var(v); :}
    | VAR QUOTED_IDENTIFIER.v ASSIGN expression.e                       {: return var(v, e); :}
    | HURL expression.e                                                 {: return hurl(e); :}
    | RETURN expression.e                                               {: return result(e); :}
    | WHILE expression.c NEWLINE+ sequence.e term* END                  {: return loop(c, block(e)); :}
    | WHILE expression.c DO sequence.e term* END                        {: return loop(c, block(e)); :}
    | UNTIL expression.c NEWLINE+ sequence.e term* END                  {: return loop(unary("not", c), block(e)); :}
    | UNTIL expression.c DO sequence.e term* END                        {: return loop(unary("not", c), block(e)); :}
    | FOR IDENTIFIER.v IN expression.e NEWLINE+ sequence.s term* END    {: return loop(v, e, block(s)); :}
    | FOR IDENTIFIER.v IN expression.e DO sequence.s term* END          {: return loop(v, e, block(s)); :}
    | statement.s COMMA IF expression.c                                 {: return suffix(s, c); :}
    | statement.s COMMA UNLESS expression.c                             {: return suffix(s, unary("not", c)); :}
    | statement.s COMMA WHILE expression.c                              {: return loop(c, s); :}
    | statement.s COMMA UNTIL expression.c                              {: return loop(unary("not", c), s); :}
    ;

expression
    = message.e {: return msg(e); :}
    ;

message
    = postfix_expression
    | message postfix_expression
    ;

postfix_expression
    = primary_expression
    | ASSIGN                                                {: return id("="); :}
    | postfix_expression.e DOT IDENTIFIER.id                {: return access(e, id); :}
    | postfix_expression.e LARG RPAREN                      {: return invocation(e); :}
    | postfix_expression.e LINDEX message.a COMMA? RSQUARE  {:
                                                                Symbol result = apply(id("[]"), e);
                                                                for (Symbol arg : a) {
                                                                    result = apply(result, arg);
                                                                }
                                                                return result;
                                                            :}
    | postfix_expression.e LARG message.a RPAREN            {:
                                                                Symbol result = e;
                                                                for (Symbol arg : a) {
                                                                    result = apply(result, arg);
                                                                }
                                                                return result;
                                                            :}
    | LFUNC opt_function_arguments.a RPAREN suffix_typespec.t APPLIES_TO expression.e
        {:
            Symbol expression = e;
            if (a == null) {
                expression = invokable(expression);
            } else {
                for (int i = a.length - 1; i >= 1; i--) {
                    expression = func(a[i], expression);
                }
                expression = func(a[0], expression, t);
            }
            return expression;
        :}
    ;

list
    = expression
    | list COMMA expression
    ;

primary_expression
    = IDENTIFIER.id                 {: return id(id); :}
    | QUOTED_IDENTIFIER.id          {: return quoted(id); :}
    | INTEGER.val                   {: return literal(val); :}
    | DOUBLE.val                    {: return literal(val); :}
    | TRUE                          {: return literal(true); :}
    | FALSE                         {: return literal(false); :}
    | NOTHING                       {: return nothing(); :}
    | CHARACTER.c                   {: return literal(c); :}
    | SYMBOL.s                      {: return symbol(s); :}
    | LPAREN expression.e RPAREN    {: return e; :}
    | QUOTE STRING.val QUOTE        {: return literal(val); :}
    | QUOTE QUOTE                   {: return literal(""); :}
    | function_literal
    | map_literal
    | list_literal
    | tuple_literal
    | set_literal
    | block
    | conditional
    | exceptional
    | DQUOTE interpolation_list.e DQUOTE                    {: return e; :}
    | TRIPLE_QUOTE STRING.val TRIPLE_QUOTE                  {: return literal(val); :}
    | TRIPLE_DQUOTE interpolation_list.e TRIPLE_DQUOTE      {: return e; :}
    | LREGEX interpolation_list.e RREGEX REGEX_OPTIONS.o    {: return regex(asList(e), o); :}
    ;

list_literal
    = LSQUARE list.e COMMA? RSQUARE {: return list(e); :}
    | LSQUARE RSQUARE               {: return list(); :}
    ;

tuple_literal
    = LPAREN COMMA? RPAREN                              {: return tuple(); :}
    | LPAREN expression.e COMMA RPAREN                  {: return tuple(e); :}
    | LPAREN expression.e COMMA list.es COMMA? RPAREN   {: return tuple(e, es); :}
    ;

set_literal
    = LCURLY COMMA RCURLY                               {: return set(); :}
    | LCURLY expression.e COMMA RCURLY                  {: return set(e); :}
    | LCURLY expression.e COMMA list.es COMMA? RCURLY   {: return set(e, es); :}
    ;

map_literal
    = LCURLY COLON RCURLY                   {: return map(); :}
    | LCURLY keyed_list.e COMMA? nl* RCURLY {: return map(e); :}
    | LCURLY map_list.e COMMA? nl* RCURLY   {: return map(e); :}
    ;

block
    = LCURLY term* RCURLY               {: return invokable(block()); :}
    | LCURLY sequence.e term* RCURLY    {: return invokable(block(e)); :}
    ;

sequence
    = statement
    | sequence term+ statement
    ;

function_literal
    = LFUNC function_arguments.a function_typespec.t APPLIES_TO expression.e RPAREN
        {:
            Symbol expression = e;
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            expression = func(a[0], expression, t);
            return expression;
        :}
    | LFUNC APPLIES_TO expression.e RPAREN
        {: return invokable(e); :}
    | LFUNC_MULTILINE function_arguments.a function_typespec.t APPLIES_TO sequence.e term* RCURLY
        {:
            Symbol expression = block(e);
            for (int i = a.length - 1; i >= 1; i--) {
                expression = func(a[i], expression);
            }
            expression = func(a[0], expression, t);
            return expression;
        :}
    ;

function_typespec
    = DOUBLE_COLON FWORD.t {: return type(qid(t)); :}
    |
    ;

opt_function_arguments
    = function_arguments.a {: return new Symbol(a); :}
    |
    ;

conditional
    = conditional_case.h default_case.e END                     {: return conditional(h, null, e); :}
    | conditional_case.h alternative_cases.t default_case.e END {: return conditional(h, t, e); :}
    ;

conditional_case
    = IF expression.c NEWLINE+ sequence.e term*     {: return condition(c, block(e)); :}
    | IF expression.c THEN sequence.e term*         {: return condition(c, block(e)); :}
    | UNLESS expression.c NEWLINE+ sequence.e term* {: return condition(unary("not", c), block(e)); :}
    | UNLESS expression.c THEN sequence.e term*     {: return condition(unary("not", c), block(e)); :}
    ;

alternative_cases
    = alternative_case
    | alternative_cases alternative_case
    ;

alternative_case
    = ELSE_IF expression.c NEWLINE+ sequence.e term*        {: return condition(c, block(e)); :}
    | ELSE_IF expression.c THEN sequence.e term*            {: return condition(c, block(e)); :}
    | ELSE_UNLESS expression.c NEWLINE+ sequence.e term*    {: return condition(unary("not", c), block(e)); :}
    | ELSE_UNLESS expression.c THEN sequence.e term*        {: return condition(unary("not", c), block(e)); :}
    ;

default_case
    = ELSE sequence.e term* {: return block(e); :}
    |                       {: return nop(); :}
    ;

exceptional
    = begin_case.u sequence.s term* embrace_cases.e ensure_case.f END   {: return begin(u, block(s), e, f); :}
    | begin_case.u sequence.s term* embrace_cases.e END                 {: return begin(u, block(s), e, null); :}
    | begin_case.u sequence.s term* ensure_case.f END                   {: return begin(u, block(s), null, f); :}
    | begin_case.u sequence.s term* END                                 {: return begin(u, block(s), null, null); :}
    ;

begin_case
    = BEGIN             {: return new Symbol(null); :}
    | use_cases.u term+ {: return new Symbol(u); :}
    ;

use_cases
    = use_case
    | use_cases term+ use_case
    ;

use_case
    = USE expression.e                      {: return use(null, e); :}
    | USE IDENTIFIER.id ASSIGN expression.e {: return use(id, e); :}
    ;

embrace_cases
    = embrace_case
    | embrace_cases embrace_case
    ;

embrace_case
    = EMBRACE IDENTIFIER.a embrace_typespec.t APPLIES_TO sequence.e term*   {: return embrace(a, t, block(e)); :}
    ;

embrace_typespec
    = COLON qualified_identifier.id {: return type(id); :}
    |                               {: return type(qid("snacks", "lang", "SnacksException")); :}
    ;

ensure_case
    = ENSURE sequence.e term* {: return block(e); :}
    ;

keyed_list
    = keyed_entry
    | keyed_list COMMA keyed_entry
    ;

keyed_entry
    = KEY_SYMBOL.k expression.v {: return entry(symbol(k), v); :}
    ;

map_list
    = map_entry
    | map_list COMMA map_entry
    ;

map_entry
    = expression.k GOES_TO expression.v {: return entry(k, v); :}
    ;

function_arguments
    = function_argument
    | function_arguments function_argument
    ;

function_argument
    = FWORD.a suffix_typespec.t {: return arg(a, t); :}
    | THROWAWAY                 {: return arg("_", null); :}
    ;

suffix_typespec
    = COLON qualified_fword.t {: return type(t); :}
    |
    ;

qualified_fword
    = FWORD.id                          {: return qid(id); :}
    | qualified_fword.ids DOT FWORD.id  {: return qid(ids, id); :}
    ;

interpolation_list
    = interpolation.e                       {: return apply(id("stringy"), e); :}
    | interpolation_list.es interpolation.e {: return apply(apply(id("concat"), es), apply(id("stringy"), e)); :}
    ;

interpolation
    = STRING.val                                {: return literal(val); :}
    | LINTERPOLATE expression.e RINTERPOLATE    {: return e; :}
    ;

opt_terms
    = terms
    |
    ;

terms
    = term
    | terms term
    ;

term
    = nl
    | SEMICOLON
    ;

nl
    = NEWLINE
    ;
